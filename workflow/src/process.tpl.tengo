// process

self := import("@milaboratory/tengo-sdk:tpl")

ll := import("@milaboratory/tengo-sdk:ll")
assets := import("@milaboratory/tengo-sdk:assets")
pframes := import("@milaboratory/tengo-sdk:pframes")
smart := import("@milaboratory/tengo-sdk:smart")
file := import("@milaboratory/tengo-sdk:file")
llPFrames := import("@milaboratory/tengo-sdk:pframes.ll")
pUtil := import("@milaboratory/tengo-sdk:pframes.util")
pConstants := import("@milaboratory/tengo-sdk:pframes.constants")

json := import("json")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")

self.awaitState("InputsLocked")
self.awaitState("params", "ResourceReady")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("presetContent", "ResourceReady")
self.awaitState("pfconvParams", "ResourceReady")

self.body(func(inputs) {
	params := inputs.params
	preset := params.preset
	inputSpec := inputs.inputSpec
	species := params.species
	blockId := params.blockId

	presetContent := inputs.presetContent.getDataAsJson()
	pfconvParams := inputs.pfconvParams

	if is_undefined(presetContent) {
		ll.panic("no presetContent")
	}

	if is_undefined(pfconvParams) {
		ll.panic("no pfconvParams")
	}

	decomposition := pUtil.decomposePfconvCfg(pfconvParams, { additionalAxesSpec: [
		inputSpec.axesSpec[0],
		{
			"name": "pl7.app/vdj/chain",
			"type": "String"
		}
		] })
	purifiedPfconvCfg := decomposition.purifiedCfg
	cloneColumnsSpec := decomposition.columnsSpec

	reports := []

	for step in presetContent.reportTypes {
		if step == "align" || step == "assemble" {
			reports = append(reports, {
				id: step,
				fileJson: "result." + step + ".report.json",
				fileTxt: "result." + step + ".report.txt"
			})
		}
	}

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	aggregationTargets := [{
		type: "Resource",
		name: "qc"
	}, {
		type: "Resource",
		name: "log"
	}, {
		type: "Resource",
		name: "clns"
	}, {
		type: "ResourceMap",
		name: "reports",
		keyLength: 2 // [reportType, reportFormat]
	}]

	ll.assert(purifiedPfconvCfg.partitionKeyLength == 0, "unexpected partition length")
	ll.assert(purifiedPfconvCfg.storageFormat == "Binary", "unexpected format")
	for columnCfg in purifiedPfconvCfg.columns {
		aggCfg := {
			type: "BinaryPartitioned",
			name: "clones/" + columnCfg.id,
			path: ["clones", columnCfg.id],
			partitionKeyLength: 1 // [chain]
		}
		aggregationTargets = append(aggregationTargets, aggCfg)
	}

	ll.assert(smart.isResource(inputs.inputData), "input data should be a resource")

	mixcrResults := llPFrames.aggregate(
		inputs.inputData, [1], mixcrAnalyzeTpl,
		aggregationTargets,
		false,
		{
			params: smart.createJsonResource({
				preset: preset,
				species: species,
				fileExtension: fileExtension,
				reports: reports
			}),
			presetContent: presetContent,
			pfconvParams: purifiedPfconvCfg
		}
	)

	clones := pframes.pFrameBuilder()
	for columnId, columnSpec in cloneColumnsSpec {
		clones.add(columnId, columnSpec, mixcrResults.output("clones/" + columnId))
	}
	clones = clones.build()

	return {
		"qc.spec": {
			kind: "PColumn",
			name: "mixcr.com/qc",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			axesSpec: [
				inputSpec.axesSpec[0]
				]
		},
		"qc.data": mixcrResults.output("qc"),

		"logs.spec": {
			kind: "PColumn",
			name: "pl7.app/log",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "Log",
			axesSpec: [
				inputSpec.axesSpec[0]
				]
		},
		"logs.data": mixcrResults.output("log"),

		"reports.spec": {
			kind: "PColumn",
			name: "mixcr.com/report",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			axesSpec: [
				inputSpec.axesSpec[0],
				{
					type: "String",
					name: "mixcr.com/report/source",
					annotations: {
						"pl7.app/label": "Source MiXCR stage"
					}
				},
				{
					type: "String",
					name: "mixcr.com/report/format",
					annotations: {
						"pl7.app/label": "Report format"
					},
					domain: {
						"pl7.app/dense": json.encode(["json", "txt"])
					}
				}
				]
		},
		"reports.data": mixcrResults.output("reports"),

		"clns.spec": {
			kind: "PColumn",
			name: "mixcr.com/clns",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			axesSpec: [ inputSpec.axesSpec[0] ]
		},
		"clns.data": mixcrResults.output("clns"),

		"clones": clones
	}
})
