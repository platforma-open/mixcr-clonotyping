//tengo:hash_override 2026-02-13

ll := import("@platforma-sdk/workflow-tengo:ll")
self := import("@platforma-sdk/workflow-tengo:tpl.light")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
assets := import("@platforma-sdk/workflow-tengo:assets")
exec := import("@platforma-sdk/workflow-tengo:exec")
pt := import("@platforma-sdk/workflow-tengo:pt")
clonotypeLabel := import(":clonotype-label")
stopCodonReplacement := import(":stop-codon-replacement")

json := import("json")
text := import("text")

self.defineOutputs("tsv", "tsvForSingleCell")

mixcrSw := assets.importSoftware("@platforma-open/milaboratories.software-mixcr:memory-from-limits")

self.body(func(inputs) {
	clnsFile := inputs[pConstants.VALUE_FIELD_NAME]

	params := inputs.params
	library := inputs.library
	isLibraryFileGzipped := params.isLibraryFileGzipped
	chains := params.chains
	exportArgs := params.exportArgs
	stopCodonTypes := params.stopCodonTypes
	stopCodonReplacements := params.stopCodonReplacements
	aminoAcidSeqColumns := params.aminoAcidSeqColumns
	aminoAcidSeqColumnPairs := params.aminoAcidSeqColumnPairs
	cdr3SeqColumns := params.cdr3SeqColumns
	
	clonotypeKeyColumns := params.clonotypeKeyColumns
	clonotypeKeyArgs := params.clonotypeKeyArgs

	cellTagColumns := params.cellTagColumns
	// if false cell key will not be hashed
	hashCellKey := params.hashCellKey
	if !hashCellKey && !is_undefined(cellTagColumns) {
		ll.assert(len(cellTagColumns) == 1, "cellTagColumns must be a single column when hashCellKey is false")
	}

    mainAbundanceColumnUnnormalizedArgs := params.mainAbundanceColumnUnnormalizedArgs
    mainAbundanceColumnIsReadCount := params.mainAbundanceColumnIsReadCount == true
    mainIsProductiveArgs := params.mainIsProductiveArgs
    mainIsProductiveColumn := params.mainIsProductiveColumn

	useProductiveFilter := is_undefined(stopCodonTypes) || len(stopCodonTypes) == 0

	exportMemGB := undefined 
	if !is_undefined(inputs.perProcessMemGB) {
		exportMemGB = int(1.0*inputs.perProcessMemGB/4.0)
		if exportMemGB < 12 {
			exportMemGB = 12
		}
	} else {
		exportMemGB = 12
	}
	ptMemGB := int(2.0*exportMemGB/3.0)
	
	
	hashKeyDerivationExpressionPt := func(sourceColumns) {
		return pt.concatStr(
			slices.map(sourceColumns, func(colName) { return pt.col(colName).fillNull("") }),
			{ delimiter: "#" }
		).hash("sha256", "base64_alphanumeric", 120)
	}

	// Exporting clones from clns file

	createExport := func(additionalAction) {
		mixcrCmdBuilder := exec.builder().
			inMediumQueue().
			mem(string(exportMemGB) + "GiB").
		    cpu(2).
			env("MI_USE_SYSTEM_CA", "true").
			software(mixcrSw).
			secret("MI_LICENSE", "MI_LICENSE").
			env("MI_LICENSE_DEBUG", "MI_LICENSE_DEBUG").
			arg("exportClones").
			arg("--dont-split-files").
			arg("--drop-default-fields").
			arg("--reset-export-clone-table-splitting").
			arg("--chains").arg(chains)
		if useProductiveFilter {
			mixcrCmdBuilder = mixcrCmdBuilder.arg("--export-productive-clones-only")
		} else {
			mixcrCmdBuilder = mixcrCmdBuilder.arg("--filter-out-of-frames")
		}

		if library {
			if isLibraryFileGzipped {
				mixcrCmdBuilder.addFile("library.json.gz", library)
			} else {
				mixcrCmdBuilder.addFile("library.json", library)
			}
		}

		additionalAction(mixcrCmdBuilder)

		return mixcrCmdBuilder.
			arg("clones.clns").
			addFile("clones.clns", clnsFile).
			arg("clones.tsv").
			saveFile("clones.tsv").
			cacheHours(3).
			run()
	}

	mixcrCmd := createExport(func(mixcrCmdBuilder) {
		for argGrp in exportArgs {
			for arg in argGrp {
				mixcrCmdBuilder.arg(arg)
			}
		}
	})

	unprocessedTsv := mixcrCmd.getFile("clones.tsv")

	result := {
		tsvForSingleCell: smart.createNullResource()
	}

	if is_undefined(clonotypeKeyColumns) {
		ll.panic("clonotypeKeyColumns is undefined")
	}

	// PTabler processing for main TSV output
	wfMain := pt.workflow().
		inMediumQueue().
		mem(ptMemGB).
		cpu(2)

	frameInputMap := {
		file: unprocessedTsv,
		xsvType: "tsv",
		schema: [ { column: "readCount", type: "Double" } ]
	}
	dfMain := wfMain.frame(frameInputMap, { inferSchema: false, id: "input_table" })

    dfMain.addColumns(
        pt.col("readCount").round().cast("Long").alias("readCount")
    )
    // Normalize isProductive column casing to strictly "true"/"false"
    if !is_undefined(mainIsProductiveColumn) {
        dfMain.addColumns(
            pt.when(pt.col(mainIsProductiveColumn).strToUpper().eq("TRUE")).
                then(pt.lit("true")).
                otherwise(pt.lit("false")).
                alias(mainIsProductiveColumn)
        )
    }
	dfMain = stopCodonReplacement.applyStopCodonReplacementsPt(dfMain, {
		aminoAcidSeqColumns: aminoAcidSeqColumns,
		aminoAcidSeqColumnPairs: aminoAcidSeqColumnPairs,
		cdr3SeqColumns: cdr3SeqColumns,
		stopCodonTypes: stopCodonTypes,
		stopCodonReplacements: stopCodonReplacements
	})

	// Filter for exclusive TRA/TRD chain assignment.
	// MiXCR --chains filter is permissive (any V/J/C gene locus match),
	// so clonotypes with shared TRDV genes pass both --chains TRA and --chains TRD.
	// Use topChains (intersection of best V/J/C hits) to enforce exclusivity.
	if chains == "TRA" || chains == "TRD" {
		dfMain = dfMain.filter(pt.col("topChains").eq(chains))
	}

	dfMain.addColumns(
		hashKeyDerivationExpressionPt(clonotypeKeyColumns).alias("clonotypeKey")
	)

	// Generate clonotypeLabel (C-XXXXX or C-XXXXX-RANK) from clonotypeKey for bulk data
	dfMain = clonotypeLabel.addClonotypeLabelColumnsPt(dfMain, "clonotypeKey", "clonotypeLabel", pt)

	dfMain.save("output.tsv")
	ptablerResultMain := wfMain.run()
	processedTsv := ptablerResultMain.getFile("output.tsv")
	result.tsv = processedTsv

	if !is_undefined(cellTagColumns) {
		mixcrForSingleCell := createExport(func(mixcrCmdBuilder) {
			mixcrCmdBuilder.
				arg("--split-by-tags").arg("Cell").
				arg("-tags").arg("Cell")

			scExportArgs := clonotypeKeyArgs + mainIsProductiveArgs + mainAbundanceColumnUnnormalizedArgs
			// Add -topChains for TRA/TRD filtering (shared TRAD locus)
			if chains == "TRA" || chains == "TRD" {
				scExportArgs = scExportArgs + [[ "-topChains" ]]
			}
			for argGrp in scExportArgs {
				for arg in argGrp {
					mixcrCmdBuilder.arg(arg)
				}
			}
		})

		unprocessedTsvForSingleCell := mixcrForSingleCell.getFile("clones.tsv")

		// PTabler processing for single-cell TSV output
		wfSingleCell := pt.workflow().
			inMediumQueue().
			mem(ptMemGB).
			cpu(2)

		frameLoadOps := {
			xsvType: "tsv",
			inferSchema: false
		}

		if mainAbundanceColumnIsReadCount {
			frameLoadOps.schema = [ { column: "readCount", type: "Double" } ]
		}

		dfSingleCell := wfSingleCell.frame(unprocessedTsvForSingleCell, frameLoadOps)

        if mainAbundanceColumnIsReadCount {
            dfSingleCell.addColumns(
                pt.col("readCount").round().cast("Long").alias("readCount")
            )
        }
        // Normalize isProductive column casing to strictly "true"/"false"
        if !is_undefined(mainIsProductiveColumn) {
            dfSingleCell.addColumns(
                pt.when(pt.col(mainIsProductiveColumn).strToUpper().eq("TRUE")).
                    then(pt.lit("true")).
                    otherwise(pt.lit("false")).
                    alias(mainIsProductiveColumn)
            )
        }

		dfSingleCell = stopCodonReplacement.applyStopCodonReplacementsPt(dfSingleCell, {
			aminoAcidSeqColumns: aminoAcidSeqColumns,
			aminoAcidSeqColumnPairs: aminoAcidSeqColumnPairs,
			cdr3SeqColumns: cdr3SeqColumns,
			stopCodonTypes: stopCodonTypes,
		stopCodonReplacements: stopCodonReplacements,
		allowedNtColumns: func() {
			allowed := []
			if !is_undefined(clonotypeKeyColumns) {
				for col in clonotypeKeyColumns {
					if text.has_prefix(col, "nSeq") {
						allowed = append(allowed, col)
					}
				}
			}
			return allowed
		}()
		})

		// Filter for exclusive TRA/TRD chain assignment (same as bulk path)
		if chains == "TRA" || chains == "TRD" {
			dfSingleCell = dfSingleCell.filter(pt.col("topChains").eq(chains))
		}

		dfSingleCell.addColumns(
			hashKeyDerivationExpressionPt(clonotypeKeyColumns).alias("clonotypeKey"),
			hashCellKey ? hashKeyDerivationExpressionPt(cellTagColumns).alias("cellKey") : pt.col(cellTagColumns[0]).alias("cellKey")
		)

		dfSingleCell.save("output.tsv")
		ptablerResultSingleCell := wfSingleCell.run()
		result.tsvForSingleCell = ptablerResultSingleCell.getFile("output.tsv")
	}

	return result
})
