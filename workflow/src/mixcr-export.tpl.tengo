ll := import("@platforma-sdk/workflow-tengo:ll")
self := import("@platforma-sdk/workflow-tengo:tpl.light")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
assets := import("@platforma-sdk/workflow-tengo:assets")
exec := import("@platforma-sdk/workflow-tengo:exec")

json := import("json")

self.defineOutputs("tsv", "tsvForSingleCell")

mixcrSw := assets.importSoftware("@platforma-open/milaboratories.software-mixcr:low-memory")
ptablerSw := assets.importSoftware("@platforma-open/software-ptabler:main")

self.body(func(inputs) {
	clnsFile := inputs[pConstants.VALUE_FIELD_NAME]

	params := inputs.params
	library := inputs.library
	isLibraryFileGzipped := params.isLibraryFileGzipped
	chains := params.chains
	exportArgs := params.exportArgs

	clonotypeKeyColumns := params.clonotypeKeyColumns
	clonotypeKeyArgs := params.clonotypeKeyArgs

	cellTagColumns := params.cellTagColumns

	mainAbundanceColumnNormalized := params.mainAbundanceColumnNormalized
	mainAbundanceColumnUnnormalized := params.mainAbundanceColumnUnnormalized
	mainAbundanceColumnNormalizedArgs := params.mainAbundanceColumnNormalizedArgs
	mainAbundanceColumnUnnormalizedArgs := params.mainAbundanceColumnUnnormalizedArgs
	mainIsProductiveColumn := params.mainIsProductiveColumn
	mainIsProductiveArgs := params.mainIsProductiveArgs

	hashKeyDerivationExpression := func(sourceColumns) {
		strJoinOperands := []
		for colName in sourceColumns {
			strJoinOperands += [ { type: "col", name: colName } ]
		}
		return {
			type: "hash",
			hashType: "sha256",
			encoding: "base64_alphanumeric",
			bits: 120,
			value: {
				type: "str_join",
				operands: strJoinOperands,
				delimiter: "#"
			}
		}
	}

	// Exporting clones from clns file

	createExport := func(additionalAction) {
		mixcrCmdBuilder := exec.builder().
			inMediumQueue().
			printErrStreamToStdout().
			dontSaveStdoutOrStderr().
			software(mixcrSw).
			secret("MI_LICENSE", "MI_LICENSE").
			arg("exportClones").
			arg("--dont-split-files").
			arg("--drop-default-fields").
			arg("--reset-export-clone-table-splitting").
			arg("--export-productive-clones-only").
			arg("--chains").arg(chains)

		if library {
			if isLibraryFileGzipped {
				mixcrCmdBuilder.addFile("library.json.gz", library)
			} else {
				mixcrCmdBuilder.addFile("library.json", library)
			}
		}

		additionalAction(mixcrCmdBuilder)

		return mixcrCmdBuilder.
			arg("clones.clns").
			addFile("clones.clns", clnsFile).
			arg("clones.tsv").
			saveFile("clones.tsv").
			cacheHours(3).
			run()
	}

	mixcrCmd := createExport(func(mixcrCmdBuilder) {
		for argGrp in exportArgs {
			for arg in argGrp {
				mixcrCmdBuilder.arg(arg)
			}
		}
	})

	unprocessedTsv := mixcrCmd.getFile("clones.tsv")

	result := {
		tsvForSingleCell: smart.createNullResource()
	}

	if is_undefined(clonotypeKeyColumns) {
		ll.panic("clonotypeKeyColumns is undefined")
	}

	ptablerSteps := [ {
		type: "read_csv",
		file: "input.tsv",
		name: "input_table",
		delimiter: "\t",
		schema: [ { column: "readCount", type: "Double" } ],
		inferSchema: false // other columns will be treated as strings
	} ]

	// rounding and casting readCount to Long
	ptablerSteps += [ {
		type: "add_columns",
		table: "input_table",
		columns: [ {
			name: "readCount",
			expression: {
				type: "cast",
				dtype: "Long",
				value: { type: "round", value: { type: "col", name: "readCount" } }
			}
		} ]
	} ]

	ptablerSteps += [ {
		type: "add_columns",
		table: "input_table",
		columns: [ {
			name: "clonotypeKey",
			expression: hashKeyDerivationExpression(clonotypeKeyColumns)
		} ]
	} ]

	ptablerSteps += [ {
		type: "write_csv",
		table: "input_table",
		file: "output.tsv",
		delimiter: "\t"
	} ]

	ptablerCmd := exec.builder().
		inMediumQueue().
		printErrStreamToStdout().
		dontSaveStdoutOrStderr().
		software(ptablerSw).
		arg("workflow.json").
		writeFile("workflow.json", json.encode({
			workflow: ptablerSteps
		})).
		addFile("input.tsv", unprocessedTsv).
		saveFile("output.tsv").
		run()

	processedTsv := ptablerCmd.getFile("output.tsv")

	result.tsv = processedTsv

	if !is_undefined(cellTagColumns) {
		mixcrForSingleCell := createExport(func(mixcrCmdBuilder) {
			mixcrCmdBuilder.
				arg("--split-by-tags").arg("Cell").
				arg("-tags").arg("Cell")

			for argGrp in (clonotypeKeyArgs + mainIsProductiveArgs + mainAbundanceColumnUnnormalizedArgs) {
				for arg in argGrp {
					mixcrCmdBuilder.arg(arg)
				}
			}
		})

		unprocessedTsvForSingleCell := mixcrForSingleCell.getFile("clones.tsv")

		ptablerStepsForSingleCell := [ {
			type: "read_csv",
			file: "input.tsv",
			name: "input_table_sc",
			delimiter: "\t",
			inferSchema: false // all columns will be treated as strings
		}, {
			type: "add_columns",
			table: "input_table_sc",
			columns: [ {
				name: "clonotypeKey",
				expression: hashKeyDerivationExpression(clonotypeKeyColumns)
			}, {
				name: "cellKey",
				expression: hashKeyDerivationExpression(cellTagColumns)
			} ]
		}, {
			type: "write_csv",
			table: "input_table_sc",
			file: "output.tsv",
			delimiter: "\t"
		} ]

		ptablerCmdSingleCell := exec.builder().
			inMediumQueue().
			printErrStreamToStdout().
			dontSaveStdoutOrStderr().
			software(ptablerSw).
			arg("workflow_sc.json").
			writeFile("workflow_sc.json", json.encode({
				workflow: ptablerStepsForSingleCell
			})).
			addFile("input.tsv", unprocessedTsvForSingleCell).
			saveFile("output.tsv").
			run()

		result.tsvForSingleCell = ptablerCmdSingleCell.getFile("output.tsv")
	}

	return result
})
