// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
render := import("@platforma-sdk/workflow-tengo:render")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
smart := import("@platforma-sdk/workflow-tengo:smart")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
file := import("@platforma-sdk/workflow-tengo:file")
llPFrames := import("@platforma-sdk/workflow-tengo:pframes.ll")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pUtil := import("@platforma-sdk/workflow-tengo:pframes.util")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")

calculateExportSpecs := import(":calculate-export-specs")

json := import("json")
text := import("text")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")
mixcrExportTpl := assets.importTemplate(":mixcr-export")
aggregateByClonotypeKeyTpl := assets.importTemplate(":aggregate-by-clonotype-key")

processSingleCellTpl := assets.importTemplate(":process-single-cell")

self.awaitState("InputsLocked")
self.awaitState("params", "ResourceReady")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("presetSpecForBack", "ResourceReady")
self.awaitState("presetContent", "ResourceReady")

chainInfos := {
	"IGHeavy": { mixcrFilter: "IGH", name: "IG Heavy", shortName: "Heavy" },
	"IGLight": { mixcrFilter: "IGK,IGL", name: "IG Light", shortName: "Light" },
	"TCRAlpha": { mixcrFilter: "TRA", name: "TCR Alpha", shortName: "Alpha" },
	"TCRBeta": { mixcrFilter: "TRB", name: "TCR Beta", shortName: "Beta" },
	"TCRGamma": { mixcrFilter: "TRD", name: "TCR Gamma", shortName: "Gamma" },
	"TCRDelta": { mixcrFilter: "TRG", name: "TCR Delta", shortName: "Delta" }
}

// Chain with higher diversity go first
receptorInfos := {
	"IG": { chains: ["IGHeavy", "IGLight"], name: "IG" },
	"TCRAB": { chains: ["TCRBeta", "TCRAlpha"], name: "TCR Alpha/Beta" }, // TODO αβ ?
	"TCRGD": { chains: ["TCRDelta", "TCRGamma"], name: "TCR Gamma/Delta" } // TODO γδ ?
}

transformSpecs := func(columns, additionalSpec) {
	return slices.map(columns, func(columnSpec) {
		return maps.deepTransform(columnSpec, additionalSpec)
	})
}

self.body(func(inputs) {

	inputSpec := inputs.inputSpec
	library := inputs.library

	preset := inputs.preset
	presetSpecForBack := inputs.presetSpecForBack.getDataAsJson()
	presetContent := inputs.presetContent

	params := inputs.params
	species := params.species
	// can be either receptors or chains
	receptorsOrChains := params.receptorsOrChains
	limitInput := params.limitInput
	blockId := params.blockId
	presetCommonName := params.presetCommonName
	isLibraryFileGzipped := params.isLibraryFileGzipped


	if is_undefined(presetSpecForBack) {
		ll.panic("no presetSpecForBack")
	}

	reports := []

	for step in presetSpecForBack.reportTypes {
		if step == "align" || step == "assemble" {
			reports = append(reports, {
				id: step,
				fileJson: "result." + step + ".report.json",
				fileTxt: "result." + step + ".report.txt"
			})
		}
	}

	hasAssembleContigs := false
	hasAssembleCells := false
	for stage in presetSpecForBack.analysisStages {
		if stage == "assembleContigs" {
			hasAssembleContigs = true
		} else if stage == "assembleCells" {
			hasAssembleCells = true
		}
	}
	isSingleCell := len(presetSpecForBack.cellTags) > 0

	// calculating clns annotations

	joinOrUndefined := func(arr) {
		if is_undefined(arr) {
			return undefined
		} else {
			return text.join(arr, ",")
		}
	}

	removeUndefined := func(m) {
		r := {}
		for k, v in m {
			if !is_undefined(v) {
				r[k] = v
			}
		}
		return r;
	}

	clnsAnnotations := removeUndefined({
		"mixcr.com/assemblingFeature": joinOrUndefined(presetSpecForBack.assemblingFeature),
		"mixcr.com/cellTags": joinOrUndefined(presetSpecForBack.cellTags),
		"mixcr.com/coveredFeaturesOnExport": joinOrUndefined(presetSpecForBack.coveredFeaturesOnExport),
		"mixcr.com/umiTags": joinOrUndefined(presetSpecForBack.umiTags),
		"pl7.app/label": "MiXCR Clonesets"
	})
	if hasAssembleContigs {
		clnsAnnotations["mixcr.com/contigsAssembled"] = "true"
	}
	if hasAssembleCells {
		clnsAnnotations["mixcr.com/cellsAssembled"] = "true"
	}

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	targetOutputs := [ {
		type: "Resource",
		spec: {
			kind: "PColumn",
			valueType: "File",
			name: "mixcr.com/qc",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			}
		},
		name: "qc"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "pl7.app/log",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "Log"
		},
		name: "log"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/clns",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			annotations: clnsAnnotations,
			valueType: "File"
		},
		name: "clns"
	}, {
		type: "ResourceMap",
		name: "reports",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/report",
			domain: {
				"pl7.app/vdj/clonotypingRunId": blockId
			},
			valueType: "File",
			axesSpec: [ {
				type: "String",
				name: "mixcr.com/report/source",
				annotations: {
					"pl7.app/label": "Source MiXCR stage"
				}
			}, {
				type: "String",
				name: "mixcr.com/report/format",
				annotations: {
					"pl7.app/label": "Report format"
				},
				domain: {
					"pl7.app/dense": string(json.encode(["json", "txt"]))
				}
			} ]
		}
	} ]

	exportSpecs := calculateExportSpecs(presetSpecForBack, blockId)

	columnsSpecPerSample := exportSpecs.columnsSpecPerSample
	columnsSpecPerSampleSc := exportSpecs.columnsSpecPerSampleSc
	columnsSpecPerClonotype := exportSpecs.columnsSpecPerClonotype
	columnsSpec := exportSpecs.columnsSpec

	clonotypeKeyColumns := exportSpecs.clonotypeKeyColumns
	clonotypeKeyArgs := exportSpecs.clonotypeKeyArgs
	cellTagColumns := exportSpecs.cellTagColumns

	// axesByClonotypeId := exportSpecs.axesByClonotypeId
	axesByClonotypeKey := exportSpecs.axesByClonotypeKey
	axesByScClonotypeKey := exportSpecs.axesByScClonotypeKey

	exportArgs := exportSpecs.exportArgs

	mainAbundanceColumn := exportSpecs.mainAbundanceColumn

	mixcrResults := pframes.processColumn(
		{ spec: inputSpec, data: inputs.inputData },
		mixcrAnalyzeTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],

			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			// will be automatically propagated to all output specs
			traceSteps: [{type: "milaboratories.mixcr-clonotyping", id: blockId, importance: 20, label: "MiXCR " + presetCommonName}],

			extra: {
				preset: preset,
				params: {
					species: species,
					limitInput: limitInput,
					fileExtension: fileExtension,
					reports: reports,
					isLibraryFileGzipped: isLibraryFileGzipped
				},
				library: library,
				presetContent: presetContent
			}
		}
	)

	clnsFiles := mixcrResults.output("clns")

	clonotypes := pframes.pFrameBuilder()

	chains := []
	receptors := []

	for chainOrReceptor in receptorsOrChains {
		if receptorInfos[chainOrReceptor] != undefined {
			receptors += [chainOrReceptor]
			chains += receptorInfos[chainOrReceptor].chains
		} else {
			if is_undefined(chainInfos[chainOrReceptor]) {
				ll.panic("chainInfo not found for %v", chainOrReceptor)
			}
			if len(receptors) > 0 {
				ll.panic("mixing receptors and chains is not allowed")
			}
			chains += [chainOrReceptor]
		}
	}

	perChainResults := {}

	for chain in chains {
		chainInfo := chainInfos[chain]
		ll.assert(!is_undefined(chainInfo), "chainInfo not found for chain %v", chain)

		//
		// Exporting CLNS -> TSV
		//

		exportOutputs := [ {
			type: "Resource",
			spec: {
				kind: "PColumn",
				name: "mixcr.com/clonotypeTable",
				domain: {
					"pl7.app/vdj/clonotypingRunId": blockId
				},
				valueType: "File"
			},
			name: "clonotypeTable",
			path: ["tsv"]
		} ]

		if !is_undefined(axesByClonotypeKey) && !isSingleCell {
			// only adding data outputs if we are in bulk mode
			exportOutputs += [ {
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: axesByClonotypeKey,
					columns: transformSpecs(columnsSpecPerSample, {
						spec: { domain: { "pl7.app/vdj/chain": chain } }
					}),
					storageFormat: "Binary",
					partitionKeyLength: 0
				},
				name: "byCloneKeyBySample",
				path: ["tsv"]
			} ]
		}

		if isSingleCell {
			exportOutputs += [ {
				type: "Resource",
				spec: {
					kind: "PColumn",
					name: "mixcr.com/clonotypeTableForSingleCell",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId
					},
					valueType: "File"
				},
				name: "clonotypeTableForSingleCell",
				path: ["tsvForSingleCell"]
			} ]
		}

		exportResults := pframes.processColumn(
			clnsFiles,
			mixcrExportTpl,
			exportOutputs,
			{
				// will be automatically propagated to all output specs
				traceSteps: [{type: "milaboratories.mixcr-clonotyping.export", id: blockId + "." + chain, importance: 80, label: chainInfo.name}],

				extra: {
					params: {
						chains: chainInfo.mixcrFilter,
						clonotypeKeyColumns: clonotypeKeyColumns,
						clonotypeKeyArgs: clonotypeKeyArgs,
						cellTagColumns: cellTagColumns,
						exportArgs: exportArgs
					}
				}
			}
		)

		//
		// Aggregating the data to produce:
		//   [clonotypeKey] -> properties
		// from:
		//   [sampleId, clonotypeKey] -> properties
		//

		aggregationOutputs := [ {
			type: "Resource",
			spec: {
				kind: "PColumn",
				name: "mixcr.com/clonotypeProperties",
				domain: {
					"pl7.app/vdj/clonotypingRunId": blockId
				},
				valueType: "File"
			},
			name: "clonotypeProperties",
			path: ["tsv"]
		} ]

		if !isSingleCell {
			aggregationOutputs += [ {
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: axesByClonotypeKey,
					columns: transformSpecs(columnsSpecPerClonotype, {
						spec: { domain: { "pl7.app/vdj/chain": chain } }
					}),
					storageFormat: "Binary",
					partitionKeyLength: 0
				},
				name: "byCloneKey",
				path: ["tsv"]
			} ]
		}

		aggregateByCloneKey := pframes.processColumn(
			exportResults.output("clonotypeTable"),
			aggregateByClonotypeKeyTpl,
			aggregationOutputs,
			{
				aggregate: ["pl7.app/sampleId"],
				extra: {
					params: {
						mainAbundanceColumn: mainAbundanceColumn,
						clonotypeColumns: slices.map(columnsSpecPerClonotype, func(col) {
							return col.column
						})
					}
				}
			}
		)

		// Collecting results for possible future single cell processing

		perChainResults[chain] = {
			tsvForSingleCell: exportResults.output("clonotypeTableForSingleCell"),
			clonotypeProperties: aggregateByCloneKey.output("clonotypeProperties")
		}

		// Adding results to the output

		if !isSingleCell {
			// only adding data outputs if we are in bulk mode
			exportResults.addXsvOutputToBuilder(clonotypes, "byCloneKeyBySample", "byCloneKeyBySample/" + chain + "/")
			aggregateByCloneKey.addXsvOutputToBuilder(clonotypes, "byCloneKey", "byCloneKey/" + chain + "/")
		}
	}

	if isSingleCell {
		for receptor in receptors {
			receptorInfo := receptorInfos[receptor]

			singleCellOutputs := [ {
				type: "Resource",
				spec: {
					kind: "PColumn",
					name: "mixcr.com/singleCellAbundanceTable",
					domain: {
						"pl7.app/vdj/clonotypingRunId": blockId
					},
					valueType: "File"
				},
				name: "abundanceTsv",
				path: ["abundanceTsv"]
			}, {
				type: "Xsv",
				xsvType: "tsv",
				settings: {
					axes: [ {
						column: "sampleId",
						spec: inputSpec.axesSpec[0]
					} ] + axesByScClonotypeKey,
					columns: transformSpecs(columnsSpecPerSampleSc, {
						spec: { domain: { "pl7.app/vdj/receptor": receptor } }
					}),
					storageFormat: "Binary",
					partitionKeyLength: 1
				},
				name: "abundanceTable",
				path: ["abundanceTsv"]
			} ]

			for chainIdx in [0, 1] {
				// "A" chain is always the one that is more diverse
				chainLetterU := ["A", "B"][chainIdx]
				chainNameU := chainInfos[receptorInfo.chains[chainIdx]].name
				chainNameL := text.to_lower(chainNameU)

				for isPrimary in [true, false] {
					pPrefixU := isPrimary ? "Primary" : "Secondary"
					pPrefixL := text.to_lower(pPrefixU)

 					// i.e. propertiesAPrimary
					propertiesTableName := "properties" + chainLetterU + pPrefixU
					// i.e. propertiesAPrimaryTsv
					propertiesTsvOutputName := propertiesTableName + "Tsv"

					singleCellOutputs += [ {
						type: "Resource",
						spec: {
							kind: "PColumn",
							name: "mixcr.com/scClonotypeTable/" + chainNameL + pPrefixU,
							domain: {
								"pl7.app/vdj/clonotypingRunId": blockId
							},
							valueType: "File"
						},
						name: propertiesTsvOutputName,
						path: [ propertiesTsvOutputName ]
					}, {
						type: "Xsv",
						xsvType: "tsv",
						settings: {
							axes: axesByScClonotypeKey,
							columns: transformSpecs(columnsSpecPerClonotype, {
								spec: {
									domain: {
										"pl7.app/vdj/receptor": receptor,
										"pl7.app/vdj/scClonotypeChain": chainLetterU
									},
									annotations: {
										"pl7.app/label": func(label) {
											return pPrefixU + " " + chainNameU + " " + label
										}
									}
								}
							}),
							storageFormat: "Binary",
							partitionKeyLength: 0
						},
						name: propertiesTableName,
						path: [ propertiesTsvOutputName ]
					} ]
				}
			}

			chainA := receptorInfo.chains[0]
			chainB := receptorInfo.chains[1]

			// Using A chain files as main PColumn for xsv conversion through pframes.processColumn.
			// Since we aggregate by sample, this is just a single pass through the data.

			singleCellResult := pframes.processColumn(
				perChainResults[chainA].tsvForSingleCell,
				processSingleCellTpl,
				singleCellOutputs,
				{
					aggregate: ["pl7.app/sampleId"],
					extra: {
						byCellTagB: perChainResults[chainB].tsvForSingleCell.data,
						propertiesA: perChainResults[chainA].clonotypeProperties.data,
						propertiesB: perChainResults[chainB].clonotypeProperties.data
					}
				}
			)

			singleCellResult.addXsvOutputToBuilder(clonotypes, "abundanceTable", "clonotypeProperties/abundance/" + receptor + "/")

			singleCellResult.addXsvOutputToBuilder(clonotypes, "propertiesAPrimary", "clonotypeProperties/" + receptor + "/aPrimary/")
			singleCellResult.addXsvOutputToBuilder(clonotypes, "propertiesASecondary", "clonotypeProperties/" + receptor + "/aSecondary/")
			singleCellResult.addXsvOutputToBuilder(clonotypes, "propertiesBPrimary", "clonotypeProperties/" + receptor + "/bPrimary/")
			singleCellResult.addXsvOutputToBuilder(clonotypes, "propertiesBSecondary", "clonotypeProperties/" + receptor + "/bSecondary/")
		}
	}

	return {
		"qc.spec": mixcrResults.outputSpec("qc"),
		"qc.data": mixcrResults.outputData("qc"),

		"logs.spec": mixcrResults.outputSpec("log"),
		"logs.data": mixcrResults.outputData("log"),

		"reports.spec": mixcrResults.outputSpec("reports"),
		"reports.data": mixcrResults.outputData("reports"),

		"clns.spec": mixcrResults.outputSpec("clns"),
		"clns.data": mixcrResults.outputData("clns"),

		clonotypes: clonotypes.build()
	}
})
